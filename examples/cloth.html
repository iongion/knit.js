
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width">
    <title>Woven Silk</title>
<!--    <link rel="stylesheet" href="/css/normalize.min.css">-->
    <script src="js/vendor/jquery-1.10.1.min.js" type="text/javascript"></script>
       
    <script src="js/vendor/poly2tri.js"></script>
    <script src="js/vendor/typeface-0.15.js"></script>
    <script src="js/vendor/helvetiker_regular.typeface.js"></script>
    <script src="js/vendor/helvetiker_bold.typeface.js"></script>
    <script src="js/vendor/helvetiker_bold_italic.typeface.js"></script>
    <script src="js/vendor/montserrat_bold.typeface.js"></script>
    <script src="js/vendor/montserrat_regular.typeface.js"></script>
    <script src="js/vendor/stalemate_regular.typeface.js"></script>
      
    <script src="js/Knit.js"></script>
    <script src="js/TypeUtil.js"></script>
    <script src="js/KnitWeb.js"></script>
<style type="text/css">
    body { background-color: black; }
</style>
  </head>
    
  <body> 
      
      <div id="canvas-container">
      </div>  
<script>
    var width = window.innerWidth;
    var height = window.innerHeight;
    $("<canvas/>", {
        id: "canvas",
    }).css({
        "position": "absolute",
        "top": 0,
        "left": 0 
    }).appendTo($("#canvas-container"));
    var canvas = $("#canvas");
    canvas[0].width = width;
    canvas[0].height = height;
    
    var context = canvas[0].getContext("2d");
    
    setInterval(update, 1000/60);
    
    var clothWidth = 30;
    var clothHeight = 25;
    var start_x = 20;
    var start_y = 100;
    var spacing = 10;
    var stiff = 0.35;
    var tear = 245;
    
    var mouseInfluence = 15;
    var mouseScale = 0.5;
    var mouseMaxDist = 15;
    
    var mouseTearInfluence = 15;
    var gravity = 1200;
    var mass = 0.1;
    var useFloor = false;
    var useTriangles = false;
    
    var fontSize = 300;
    var steps = 6;
//    var face = TypeUtil.getFace("helvetiker");
    var face = TypeUtil.getFace("montserrat");
//    var face = TypeUtil.getFace("stalemate");
    
    var enableWind = false;
    var showAsCloth = true;
    
    var world = new Knit.World(new Knit.Vec2(0, gravity));
    
    
    world.setPinRemoveInfluence(50);
    
    var testShape = null;
    var mouseX=0, mouseY=0;
    
    var web = null;
    
    if (useFloor) {
        world.bounds = new Knit.Rect(0, 0, width, height);
        world.floor = height-5;
    }
    
    function showText(text) {
        var xPos = start_x;
        var yPos = start_y;
        
        for (var i=0; i<text.length; i++) {
            var res = createTextTriangulated(xPos, yPos, face, text.charAt(i), steps, mass);
            var xOff = res.xadvance;
            if (xOff === null)
                continue;
            xPos += xOff;
        }
    }
    
    $(document).keypress(function(e) {
        world.points = [];
        createWeb();
        
//        createCloth();
    }); 
    $(function() {
        createWeb();
//        createCloth();
        
//        testShape = createTextTriangulated(start_x, start_y, face, 'T', steps, mass, true);
    });
    
    var mouseDown = false;
    canvas.mousedown(function(ev) {
        if (ev.which == 1)
            mouseDown = true;
    });
    canvas.mouseup(function(ev) {
        if (ev.which == 1)
            mouseDown = false;
    });
     
    canvas.mousemove(function(ev) {
//        if (mouseDown) {
            world.applyTear(ev.clientX, ev.clientY, mouseTearInfluence);
            world.applyMotion(ev.clientX, ev.clientY, mouseInfluence, mouseScale, mouseMaxDist);
//        } else
//            world.applyMotion(ev.clientX, ev.clientY, mouseInfluence, mouseScale, mouseMaxDist);
        mouseX = ev.clientX;
        mouseY = ev.clientY;
    });
    
    function createCloth() {
        for (var y=0; y<=clothHeight; y++) {
            for (var x=0; x<=clothWidth; x++) {
                var p = new Knit.PointMass(start_x + x * spacing, start_y + y * spacing, 2);
                
                (x!==0) && p.attach( world.points[world.points.length-1], spacing, stiff, tear );  
                (y===0) && p.pin( p.position.x, p.position.y );
                (y!==0) && p.attach( world.points[ x + (y - 1) * (clothWidth + 1)], spacing, stiff, tear );            
                
                world.points.push(p);
            }
        }
    }
    
    function lerp(v0, v1, t) {
        return v0*(1-t)+v1*t;
    }
    
    
    var stepper = 100;
    
    var Web = function(spirals, spokes, radius, hubRadius, cx, cy) {
        this.spirals = spirals || 10;
        this.spokes = spokes || 10;
        this.radius = radius || 100;
        this.hubRadius = hubRadius || 20;
        this.cx = cx || 0;
        this.cy = cy || 0;
        
        var step = 360 / this.spokes;
        this.spiralPoints = [];
        var i = 0;
        
        this.spiralPoints.push( new Knit.Vec2(this.cx, this.cy) );
        
        for (i=0; i<360 * this.spirals + step; i+=step) {
            //var angle = i + rnd(-10, 10);
            var jitterAngle = 0;
            var angle = i + jitterAngle;
            
            var dx = Math.cos(angle * (Math.PI / 180));
            var dy = Math.sin(angle * (Math.PI / 180));
            
            var hubX = dx * this.hubRadius + this.cx;
            var hubY = dy * this.hubRadius + this.cy;
            
            var jitterRadius = this.radius;
            
            
            
            var spiralRadius = (i/360) * (this.radius-this.hubRadius) / this.spirals;
            spiralRadius *= (i / (360 * this.spirals + step));
            
            var spiralX = dx * (spiralRadius) + hubX;
            var spiralY = dy * (spiralRadius) + hubY;
            
            this.spiralPoints.push( new Knit.Vec2(spiralX, spiralY) );
            
//            var off = radius / (spirals);
//            var lastSpiralRadius = ((i)/360) * (radius) / spirals - off;
//            var nsx = dx * (lastSpiralRadius) + cx;
//            var nsy = dy * (lastSpiralRadius) + cy;
//            
//            context.beginPath();
//            context.strokeStyle = randColors[ c % randColors.length ];
//            context.moveTo(nsx, nsy);
//            context.lineTo(spiralX, spiralY);
//            context.stroke();
            
            
        }
        this.fabric = [];
       
        var p = null;
        for (i=0; i<this.spiralPoints.length; i++) {
            var curr = this.spiralPoints[i];
            var mass = i==0 ? 5 : 5;
            p = new Knit.PointMass(curr.x, curr.y, mass);
             
            //before point
            //skip first since it will be the center
            if (i>1 && i<this.spiralPoints.length-1 - this.spokes) {
                var dist = 0;
                var other = world.points[i-1];
                p.attach( other, null, 0.05, tear );   
            }
            
            if (i < this.spokes && i>0 && (i%2==0 || Math.random() < 0.5)) { 
                p.attach( world.points[0], null, 0.01, tear);
            }
            
//            if (i>0 && i<10)
//                p.attach(world.points[0], spacing, stiff, tear);
            
//            if (i+1 < world.points.length-1)
//                p.attach( world.points[i+1], spacing, stiff, tear );
            
            var before = (world.points.length-1 - this.spokes+1);
            if (before > 0 && before < world.points.length-1) {
                var spanStiff = 0.025;  
                var cnstr = p.attach( world.points[before], null, spanStiff, tear );
                cnstr.restingDistance *= 0.5; 
            }
//            if (i > this.spiralPoints.length - this.spokes)
            
//            p.pin(p.position.x, p.position.y, false);
            
//            if (i==0)
            
//            else
//            if (i>this.spiralPoints.length - spokes)
//                p.pin(curr.x, curr.y, true);
            
//            (x!==0) && p.attach( world.points[world.points.length-1], spacing, stiff, tear );  
//            (y===0) && p.pin( p.position.x, p.position.y );
//            (y!==0) && p.attach( world.points[ x + (y - 1) * (clothWidth + 1)], spacing, stiff, tear );            
             
            world.points.push(p);
        }
        
        
        
        
        for (i=0; i<world.points.length; i++) {
            p = world.points[i];
            
            if ((i > world.points.length - 1 - this.spokes))
                p.pin(p.position.x, p.position.y, false);
            
            if (i==1) {
                p.attach(world.points[i+this.spokes - 1], null, 0.05, tear);   
                
            }
             
            var after = (i + this.spokes);
            if (after < world.points.length-1) {
//                p.attach( world.points[after], spacing, stiff, tear );
            }
        }
        
        //make some irregularities for N% of the web
        //but don't affect first or last spiral
        var j;
        var randStickies = randIndices(world.points.length-1-this.spokes, this.spokes, 0.20, 0.25);
        for (i=0; i<randStickies.length; i++) {
            j = randStickies[i];
            
            if (j%2!==0)
                continue;
            
            var offRnd = Math.random() ? -1 : 1;
            var spanRnd = Math.random() > 0.5 ? 1 : -1;
            var otherIdx = j + (spanRnd * this.spokes) + offRnd;
            world.points[j].attach( world.points[otherIdx], null, 0.05, tear );
            
        } 
        
        var randCuts = randIndices(world.points.length-1-this.spokes, this.spokes, 0.01, 0.2); 
//        console.log(randCuts.length); 
        for (i=0; i<randCuts.length; i++) {
            j = randCuts[i];
            world.points[j].constraints.splice(0, 1);
             
            for (var k=0; k<world.points[j].constraints.length; k++) {
                world.points[j].constraints[k].restingDistance *= 0.75;   
            }
        }
        
        //randomize edges
        for (i=this.spokes; i<world.points.length; i++) {
            //tear some randomly?
//             if (i < world.points.length-1-this.spokes && Math.random() < 0.05)
//                world.points[i].constraints = [];
            
            if (i == world.points.length- ~~(this.spokes/2) || i == world.points.length-1) {
//                world.points[i].unpin();
            }
        }
    };
    
    function randIndices(arrayLen, off, percentLow, percentHigh) {
        var num = ~~(arrayLen * rnd(percentLow, percentHigh));
        var idx = [];
        for (var i=off; i<arrayLen; i++) {
            idx.push(i);
        }
        idx = shuffle(idx);
        return idx.splice(0, num);
    }
    
    function shuffle(array) {
        var counter = array.length, temp, index;
    
        // While there are elements in the array
        while (counter--) {
            // Pick a random index
            index = (Math.random() * counter) | 0;
    
            // And swap the last element with it
            temp = array[counter];
            array[counter] = array[index];
            array[index] = temp;
        }
    
        return array;
    }
    
    function createWeb() { 
        web = new Web(10,15, Math.min(width, height)*0.25, 1, width/2, height/2);
//        console.log(web.spiralPoints[100].y);  
    }
    
    var randColors = [];
    for (var i=0; i<100; i++) {
        randColors.push( "rgba("+ ~~(Math.random()*255) +", " + ~~(Math.random()*255) +", "+ ~~(Math.random()*255) +", 1.0)" );
           
    }
    
    function rnd(start, end) {
        return start + Math.random() * (end - start);   
    };

    
    function update() { 
        context.clearRect(0, 0, width, height);
        
        world.step(.016);

        var spirals = 2;
        var spokes = 20;
        var radius = 100;
        var hubRadius = 20;
        var step = 360 / spokes;
        var cx = 250;
        var cy = 250;
        context.fillStyle = "black";
        context.strokeStyle = "white";
        
        
        
        context.save();
        context.beginPath();
        
//        context.translate(150, 150);
        if (web!==null) {
            var spokes = web.spokes;
            var points = web.spiralPoints;
            context.lineTo(points[0].x, points[0].y);
            for (var j=0; j<points.length; j++) {
                var p = points[j];
                context.fillStyle = "gray";
                 
                context.lineTo(p.x, p.y);
//                context.fillRect(p.x, p.y, 2, 2);
            }
            
            
            var last = points[points.length-1 - spokes];
            context.fillStyle = "red";
            
//            context.fillRect(last.x, last.y, 4, 4);
        }
        
//        context.stroke();
        context.restore();
      
        
        /*
        for (var i=0; i<360; i+=step) {
            var dx = Math.cos(i * (Math.PI / 180));
            var dy = Math.sin(i * (Math.PI / 180));
            
            
//            context.moveTo(cx, cy);
//            context.lineTo(x, y);
            
            for (var j=0; j<spirals+1; j++) {
                var off = (radius / (spirals));
                
                
                var x = dx * (radius) + cx;
                var y = dy * (radius) + cy;
                
                var t = (j)/(spirals);
                var nx = lerp(cx, x, t);
                var ny = lerp(cy, y, t);
                
//                context.fillRect(nx-1, ny-1, 2, 2);
            }
        }
        
        context.closePath();
        context.stroke();
        
        context.beginPath();
//        context.moveTo(cx, cy);
        
        
        if (enableWind) {
            context.fillStyle = "black";
            stepper++;
            if (stepper>1000)
                stepper = 100;
            var windX = width/2 + Math.sin(stepper*0.0035 * Math.cos(stepper*0.01)) * width/2;
            var windY = height/2 + Math.sin(stepper*0.05) * height/2;
            
//            var windY = height / 2;
//            var windX = width / 2 + Math.sin(stepper * 0.05) * width/2;
            context.fillRect(windX, windY, 10, 10);
            world.applyTear(windX, windY, mouseInfluence);
            world.applyMotion(windX, windY, mouseInfluence, mouseScale, mouseMaxDist);
        }
        
        if (testShape!==null) {
            context.fillStyle = pointInComplexShape(testShape, mouseX, mouseY) ? "blue" : "red";
                
            var polys = testShape.polygons;
            context.save();
            for (var k=0; k<polys.length; k++) {
                context.beginPath();    
                var pt;
                
                context.strokeStyle= "red";
                
                var shape = polys[k];
                
                context.moveTo(shape.contour[0].x, shape.contour[0].y);
                //draw shape
                for (var v=0; v<shape.contour.length; v++) {
                    pt = shape.contour[v];
                    
                    context.lineTo(pt.x, pt.y); 
                }
                //draw holes
                for (var v=0; v<shape.holes.length; v++) {
                    var h = shape.holes[v];
                    
                    context.moveTo(h[0].x, h[0].y);
                    for (var count=0; count<h.length; count++) {
                        pt = h[count];
                        context.lineTo(pt.x, pt.y); 
                    } 
                }
                
                context.closePath();
                context.fill();
                
            }
            context.restore();
            
             var sz = 2;
            context.fillStyle = "black";
            for (var y=0; y<(testShape.lineHeight/spacing); y++) {
                for (var x=0; x<(testShape.xadvance/spacing); x++) {
                    var xp = x * spacing - sz/2, yp = y * spacing - sz/2;
                    if (pointInComplexShape(testShape, xp, yp))
                        context.fillRect(xp, yp, sz, sz);
                }
            }
        }
        
//        var near = nearestPoint(testShape.polygons[0].contour, mouseX, mouseY);
//        if (near) {
//            context.fillStyle = "black";
//            context.fillRect(near.x, near.y, 3, 3);
//        }
//        
       */
        
        
        var i = world.points.length;
        context.beginPath();
        while (i-- > 1) {
            var p = world.points[i];    
            context.fillStyle = "red";
            context.strokeStyle = "rgba(255,255,255,0.75)";
            context.lineWidth = 0.5;
            
            for (var j=0; j<p.constraints.length; j++) {
                var c = p.constraints[j];
                context.moveTo(c.p1.position.x, c.p1.position.y);
                context.lineTo(c.p2.position.x, c.p2.position.y);
            }
            
//                context.fillRect(c.p1.position.x, c.p1.position.y, 2, 2);
            
//            context.moveTo(p.position.x, p.position.y);
//            conte
//            context.fillRect(p.position.x, p.position.y, 5, 5);
        }
        context.closePath();
        context.stroke();
        
        
//        context.fontStyle = "arial";
//        context.fillStyle = "black"; 
//        context.fillText(world.points.length, 50, 50);
    }
</script>
       
<!--      <div>Hi thasere</div>-->
  </body>
</html>