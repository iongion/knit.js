
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width">
    <title>Woven Silk</title>
<!--    <link rel="stylesheet" href="/css/normalize.min.css">-->
    <script src="js/vendor/jquery-1.10.1.min.js" type="text/javascript"></script>
       
    <script src="js/vendor/poly2tri.js"></script>
    <script src="js/vendor/typeface-0.15.js"></script>
    <script src="js/vendor/helvetiker_regular.typeface.js"></script>
    <script src="js/vendor/helvetiker_bold.typeface.js"></script>
    <script src="js/vendor/helvetiker_bold_italic.typeface.js"></script>
    <script src="js/vendor/montserrat_bold.typeface.js"></script>
    <script src="js/vendor/montserrat_regular.typeface.js"></script>
    <script src="js/vendor/stalemate_regular.typeface.js"></script>
      
    <script src="js/Knit.js"></script>
    <script src="js/TypeUtil.js"></script>
  </head>
    
  <body> 
      
      <div id="canvas-container">
      </div>  
<script>
    var width = window.innerWidth;
    var height = 500;
    $("<canvas/>", {
        id: "canvas",
    }).css({
        "position": "absolute",
        "top": 0,
        "left": 0 
    }).appendTo($("#canvas-container"));
    var canvas = $("#canvas");
    canvas[0].width = width;
    canvas[0].height = height;
    
    var context = canvas[0].getContext("2d");
    
    setInterval(update, 1000/60);
    
    var clothWidth = 30;
    var clothHeight = 25;
    var start_x = 20;
    var start_y = 100;
    var spacing = 6;
    var stiff = 1.0;
    var tear = 300;
    
    var mouseInfluence = 10;
    var mouseScale = 0.4;
    var mouseMaxDist = 15;
    
    var mouseTearInfluence = 5;
    var gravity = 50;
    var mass = 1.;
    var useFloor = true;
    var useTriangles = false;
    
    var fontSize = 300;
    var steps = 6;
//    var face = TypeUtil.getFace("helvetiker");
    var face = TypeUtil.getFace("montserrat");
//    var face = TypeUtil.getFace("stalemate");
    
    var enableWind = false;
    var showAsCloth = true;
    
    var world = new Knit.World(new Knit.Vec2(0, gravity));
    
    
    world.setPinRemoveInfluence(50);
    
    var testShape = null;
    var mouseX=0, mouseY=0;
    
    if (useFloor) {
        world.bounds = new Knit.Rect(0, 0, width, height);
        world.floor = height-5;
    }
    
    function showText(text) {
        var xPos = start_x;
        var yPos = start_y;
        
        for (var i=0; i<text.length; i++) {
            var res = createTextTriangulated(xPos, yPos, face, text.charAt(i), steps, mass);
            var xOff = res.xadvance;
            if (xOff === null)
                continue;
            xPos += xOff;
        }
    }
    
    $(document).keypress(function(e) {
        world.points = [];
        var result = createTextTriangulated(start_x, start_y, face, String.fromCharCode(e.which), steps, mass);
        if (result===null) {
            showText(showAsCloth ? "fabric" : "debris");   
        }
    }); 
    $(function() {
        showText("fabric");
        
//        testShape = createTextTriangulated(start_x, start_y, face, 'T', steps, mass, true);
    });
    
    var mouseDown = false;
    canvas.mousedown(function(ev) {
        if (ev.which == 1)
            mouseDown = true;
    });
    canvas.mouseup(function(ev) {
        if (ev.which == 1)
            mouseDown = false;
    });
     
    canvas.mousemove(function(ev) {
        if (mouseDown) {
            world.applyTear(ev.clientX, ev.clientY, mouseTearInfluence);
            world.applyMotion(ev.clientX, ev.clientY, mouseInfluence, mouseScale, mouseMaxDist);
        } else
            world.applyMotion(ev.clientX, ev.clientY, mouseInfluence, mouseScale, mouseMaxDist);
        mouseX = ev.clientX;
        mouseY = ev.clientY;
    });
    
    function createCloth() {
        for (var y=0; y<=clothHeight; y++) {
            for (var x=0; x<=clothWidth; x++) {
                var p = new Knit.PointMass(start_x + x * spacing, start_y + y * spacing, 2);
                
                (x!==0) && p.attach( world.points[world.points.length-1], spacing, stiff, tear );  
                (y===0) && p.pin( p.position.x, p.position.y );
                (y!==0) && p.attach( world.points[ x + (y - 1) * (clothWidth + 1)], spacing, stiff, tear );            
                
                world.points.push(p);
            }
        }
    }
    
    function indexOfPointInList(other, list) {
        for (var i=0; i<list.length; i++) {
            var p = list[i];
            if (p.x == other.x && p.y == other.y)
                return i;
        }
        return -1;
    }
    
    function isClockwise(points) {
        var sum = 0;
        for (var i=0; i<points.length-1; i++) {
            sum += (points[i+1].x - points[i].x) * (points[i+1].y + points[i].y);
        }
        return sum > 0;
    }
    
    function asPointSet(points) {
        var contour = [];
        
        
        for (var n=0; n<points.length; n++) {
            var x = points[n].x;
            var y = points[n].y;
                    
            var np = new poly2tri.Point(x, y);
            
            if (indexOfPointInList(np, contour) === -1) {
                //check collinearity
                if (contour.length > 2) {
                    var p2x = contour[contour.length-1].x;
                    var p2y = contour[contour.length-1].y;
                    
                    var p3x = contour[contour.length-2].x;
                    var p3y = contour[contour.length-2].y;
                    
                    var col = (p3x - x) * (p2y - y) + (p3y - y) * (x - p2x);
                    var eps = 0.05;
                    if (col > -eps && col < eps) {
//                        console.log("colin");
//                        contour.splice(contour.length-1, 1);
//                        contour.splice(contour.length-2, 1);
//                        continue;   
//                        np.x += Math.random()*eps;
//                        np.y += Math.random()*eps;
                    }
                }
                
                contour.push(np);
            }
        }
        return contour;
    }
    
    
    function distSq(p1, p2) {
        var dx = p1.x - p2.x, dy = p1.y - p2.y;
        return dx * dx + dy * dy;   
    }
    
    function simplifySet(points, sqTolerance) {
        if (points < 3)
            return points;
        
        var out = [];
        var len = points.length;
        
        var pt = new poly2tri.Point(0, 0);
        var prevPoint = points[0];
        
        for (var i=1; i<len; i++) {
            pt = points[i];
            if (distSq(pt, prevPoint) > sqTolerance) {
                out.push(pt);
                prevPoint = pt;
            }
        }
        
        if (!prevPoint.equals(pt))
            out.push(pt);
        
        return out;
    }
    
    function addShapeMass(sweep, start_x, start_y) {
        sweep.triangulate();
        var triangles = sweep.getTriangles() || [];
        
        for (var i=0; i<triangles.length; i++) {
            var tri = triangles[i];
            var pointMasses = [];
            var len;
            
            for (var k=0; k<3; k++) {
                var tpoint = tri.getPoint(k);
                
                var p = new Knit.PointMass(start_x + tpoint.x, start_y + tpoint.y, mass);
                if (k>0) {
                    var pOther = pointMasses[k-1];
                    len = pOther.position.distance(p.position);
                    
                    p.attach( pOther, len, stiff, tear );
                }
                pointMasses.push(p);
                world.points.push(p);
            }
            
            if (useTriangles) {
                var p1 = pointMasses[0];
                var p2 = pointMasses[pointMasses.length-1];
                len = p2.position.distance(p1.position);
                
                p1.attach(p2, len, stiff, tear);
            }
        }
    }
    
    function addClothShapeMass(fontShape, start_x, start_y, mass) {
        var cloth_height = (fontShape.lineHeight/spacing);
        var cloth_width = (fontShape.xadvance/spacing);
        
        
        var grid = [];
        var x, y;
        for (y=0; y<cloth_height; y++) {
            grid[y] = [];
            var row = grid[y];
            
            for (x=0; x<cloth_width; x++) {
                var xp = x * spacing, 
                    yp = y * spacing;
                
                row[x] = null;
                
                if (pointInComplexShape(fontShape, xp, yp)) {
                    var jitter = 1.5; 
                    var jitterX = Math.random()*jitter;
                    var jitterY = Math.random()*jitter;
                    var p = new Knit.PointMass(xp + start_x + jitterX, yp + start_y + jitterY, mass);
                    
                    if (x > 0 && row[x-1]!==null)
                        p.attach(row[x-1], spacing, stiff, tear);
                    
                    if (y > 0) {
                        var otherRow = grid[y-1];
                        
                        if (x < otherRow.length-1 && otherRow[x]!==null) {
                            p.attach(otherRow[x], spacing, stiff, tear);
                        }
                        
//                        if (x >= otherRow.length-1 && otherRow[x]===null) 
//                            p.pin(p.position.x, p.position.y, true);
                    }
                    
//                    if ((x*y) % 50 == 0)
//                        p.pin(p.position.x, p.position.y, true);
                    
//                    if (world.points.length<4)
                        p.pin(p.position.x, p.position.y, true);
                        
                    row[x] = p;
                    world.points.push(p);
                }
                 
//                
//                (y===0) && p.pin( p.position.x, p.position.y );
//                (y!==0) && p.attach( world.points[ x + (y - 1) * (cloth_width + 1)], spacing, stiff, tear );            
                
                
                
                
            }
        }
        
        //apply pins
        for (var i=0; i< world.points.length/3; i++) {
            var wp = world.points[Math.floor(Math.random()*world.points.length)];
//            var spd = .15;
//            if (wp) {
//                wp.position.x += Math.sin(i)*spd;
//                wp.position.y += Math.sin(i)*spd;
//            }
        }
        
        
    }
    
    function createTextTriangulated(start_x, start_y, face, char, steps, mass, ignoreWorld) {
        var shapes = TypeUtil.getPointLists(face, fontSize, char, steps);
//        var shapes = pointsFromGlyph(face, style, char, steps);
        if (shapes==null)
            return null;
        
        var windingClockwise = false;
        var sweep = null;
        var glyph = face.glyphs[char];
        
        var fontShape = {
            polygons: [],
            
            xadvance: 0,
            lineHeight: 0
        };
        var poly = {holes:[], contour:[]};
        
        for (var j=0; j<shapes.length; j++) {
            var points = shapes[j];
            var pointMasses = [];
            
            //check the winding order
            if (j==0) {
                windingClockwise = isClockwise(points);
            }
            
            try {
                var set = asPointSet(points);
                
//                var tolerance = 8;
//                set = simplifySet(set, tolerance * tolerance);
                
                //if the sweep has already been created, maybe we're on a hole?
                if (sweep !== null) {
                    var clock = isClockwise(points);
                    
                    //we have a hole...
                    if (windingClockwise !== clock) {
                        if (!ignoreWorld)
                            sweep.addHole( set );
                        poly.holes.push(points);
                    } else {
                        //no hole, so it must be a new shape.
                        //add our last shape
                        fontShape.polygons.push(poly);
                        if (!ignoreWorld && !showAsCloth)
                            addShapeMass(sweep, start_x, start_y);
                        
                        //reset the sweep for next shape
                        if (!ignoreWorld)
                            sweep = new poly2tri.SweepContext(set);
                        poly = {holes:[], contour:points};
                    }
                } else {
                    if (!ignoreWorld)
                        sweep = new poly2tri.SweepContext(set);   
                    poly = {holes:[], contour:points};
                }
            } catch (e) {
                console.log(e);
                return null;
            }
        }
        
        //if the sweep is still setup, then triangulate it
        if (sweep !== null) {
            try {
                fontShape.polygons.push(poly);
                if (!ignoreWorld && !showAsCloth)
                    addShapeMass(sweep, start_x, start_y);
            } catch (e) {
                console.log(e);
                return null;
            }
        }
        
        var pointScale = TypeUtil.getPointScale(face, fontSize);
        fontShape.xadvance = (glyph && glyph.ha) ? glyph.ha * pointScale : 0;
        fontShape.lineHeight = TypeUtil.getFaceHeight(face, fontSize);
        
        if (showAsCloth)
            addClothShapeMass(fontShape, start_x, start_y, mass);
        return fontShape;
    }
    
    function pointInComplexShape(fontShape, testx, testy) {
        //TODO: make more robust by searching within contours first, then holes
        
        //for each shape..
        //first check holes
        for (var i=0; i<fontShape.polygons.length; i++) {
            var shape = fontShape.polygons[i];
            for (var j=0; j<shape.holes.length; j++) {
                if (pointInPoly(shape.holes[j], testx, testy))
                    return false;
            }
            if (pointInPoly(shape.contour, testx, testy)) {
                return true;
            }
        }
        return false;
    }
    
    function nearestPoint(points, testx, testy, maxRadiusSq) {
        var i = points.length;
        
        var nearestDistSq = Number.MAX_VALUE;
        var nearestPoint = null;
        while (i--) {
            var dx = testx - points[i].x;
            var dy = testy - points[i].y;
            var len2 = (dx * dx + dy * dy);
            
            if (len2 < maxRadiusSq && len2 < nearestDistSq) {
                nearestPoint = points[i];
                nearestDistSq = len2;
            }
        }
        return nearestPoint;
    }
    
    function pointInPoly(points, testx, testy) {
        var nvert = points.length;
        var i, j, c = 0;
        for (i=0, j=nvert-1; i<nvert; j=i++) {
            if ( ((points[i].y>testy) != (points[j].y>testy)) &&
                (testx < (points[j].x-points[i].x) * (testy-points[i].y)
                 / (points[j].y-points[i].y) + points[i].x) ) {
                c = !c;
            }
        }
        return c;
    }
    
    var stepper = 100;
    
    function update() { 
        context.clearRect(0, 0, width, height);
        
        world.step(.016);

        if (enableWind) {
            context.fillStyle = "black";
            stepper++;
            if (stepper>1000)
                stepper = 100;
            var windX = width/2 + Math.sin(stepper*0.0035 * Math.cos(stepper*0.01)) * width/2;
            var windY = height/2 + Math.sin(stepper*0.05) * height/2;
            
//            var windY = height / 2;
//            var windX = width / 2 + Math.sin(stepper * 0.05) * width/2;
            context.fillRect(windX, windY, 10, 10);
            world.applyTear(windX, windY, mouseInfluence);
            world.applyMotion(windX, windY, mouseInfluence, mouseScale, mouseMaxDist);
        }
        
        if (testShape!==null) {
            context.fillStyle = pointInComplexShape(testShape, mouseX, mouseY) ? "blue" : "red";
                
            var polys = testShape.polygons;
            context.save();
            for (var k=0; k<polys.length; k++) {
                context.beginPath();    
                var pt;
                
                context.strokeStyle= "red";
                
                var shape = polys[k];
                
                context.moveTo(shape.contour[0].x, shape.contour[0].y);
                //draw shape
                for (var v=0; v<shape.contour.length; v++) {
                    pt = shape.contour[v];
                    
                    context.lineTo(pt.x, pt.y); 
                }
                //draw holes
                for (var v=0; v<shape.holes.length; v++) {
                    var h = shape.holes[v];
                    
                    context.moveTo(h[0].x, h[0].y);
                    for (var count=0; count<h.length; count++) {
                        pt = h[count];
                        context.lineTo(pt.x, pt.y); 
                    } 
                }
                
                context.closePath();
                context.fill();
                
            }
            context.restore();
            
             var sz = 2;
            context.fillStyle = "black";
            for (var y=0; y<(testShape.lineHeight/spacing); y++) {
                for (var x=0; x<(testShape.xadvance/spacing); x++) {
                    var xp = x * spacing - sz/2, yp = y * spacing - sz/2;
                    if (pointInComplexShape(testShape, xp, yp))
                        context.fillRect(xp, yp, sz, sz);
                }
            }
        }
        
//        var near = nearestPoint(testShape.polygons[0].contour, mouseX, mouseY);
//        if (near) {
//            context.fillStyle = "black";
//            context.fillRect(near.x, near.y, 3, 3);
//        }
//        
       
        
        var i = world.points.length;
        context.beginPath();
        while (i-- > 1) {
            var p = world.points[i];    
            context.fillStyle = "red";
            context.strokeStyle = "rgba(25,25,25,0.95)";
            context.lineWidth = 0.5;
            
            for (var j=0; j<p.constraints.length; j++) {
                var c = p.constraints[j];
                context.moveTo(c.p1.position.x, c.p1.position.y);
                context.lineTo(c.p2.position.x, c.p2.position.y);
            }
            
//                context.fillRect(c.p1.position.x, c.p1.position.y, 2, 2);
            
//            context.moveTo(p.position.x, p.position.y);
//            conte
//            context.fillRect(p.position.x, p.position.y, 5, 5);
        }
        context.closePath();
        context.stroke();
        
//        context.fontStyle = "arial";
//        context.fillStyle = "black"; 
//        context.fillText(world.points.length, 50, 50);
    }
</script>
       
<!--      <div>Hi thasere</div>-->
  </body>
</html>